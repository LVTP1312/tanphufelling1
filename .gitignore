-- ======================= STRONG TELEPORT BOOTSTRAP (EMBED) =======================
-- File name: TanPhu_Brainrot_Stealth_Dual.lua  (edit SELF_FILE if you rename)
local SELF_FILE = "TanPhu_Brainrot_Stealth_Dual.lua"
local HttpService = game:GetService("HttpService")
local qtp = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)

-- Read current file and embed its source (so it runs after teleport even if readfile/loadfile fail)
local SRC = nil
pcall(function()
  if isfile and readfile and isfile(SELF_FILE) then
    SRC = readfile(SELF_FILE)
  end
end)
local SRC_B64 = ""
if type(SRC)=="string" and #SRC>0 then
  SRC_B64 = HttpService:Base64Encode(SRC)
end

if qtp then
  local queued = ([[
    repeat task.wait() until game:IsLoaded()
    local HttpService = game:GetService("HttpService")
    -- Load from embedded source first
    local ok, src = pcall(function() return HttpService:Base64Decode("%s") end)
    if ok and type(src)=="string" and #src>0 then
      local f = loadstring(src)
      if f then f() end
    else
      -- Fallback to local file
      if loadfile and isfile and isfile("%s") then
        loadfile("%s")()
      elseif readfile and loadstring then
        local ok2, raw = pcall(readfile, "%s")
        if ok2 and raw then pcall(loadstring(raw)) end
      end
    end
  ]]):format(SRC_B64, SELF_FILE, SELF_FILE, SELF_FILE)
  pcall(qtp, queued)
end
-- ============================= END TELEPORT BOOTSTRAP ============================


-- ===================[ TANPHU - BRAINROT NOTIFY (DUAL, STEALTH) ]=================
-- Always-on, background, silent. ASCII only (no unicode).
local SILENT = true          -- keep true for silent run (no F9 spam)
local Players     = game:GetService("Players")
local HttpService = game:GetService("HttpService")

if SILENT then local function nop(...) end print=nop warn=nop end

-- -------------- shared helpers (stateless) --------------
local function _wh_post_json(url, tbl)
  local body = HttpService:JSONEncode(tbl)
  local headers = {["Content-Type"]="application/json"}
  local req = (syn and syn.request) or http_request or request or (http and http.request)
  if not req then return false, "no http" end
  local ok, res = pcall(function() return req({Url=url, Method="POST", Headers=headers, Body=body}) end)
  if ok and res and (res.StatusCode==204 or res.StatusCode==200) then return true end
  if ok and res and res.StatusCode==429 then
    local h = res.Headers or res.headers or {}
    local retry = tonumber(h["Retry-After"] or h["retry-after"] or 2) or 2
    task.wait(math.clamp(retry,1,10))
    res = req({Url=url, Method="POST", Headers=headers, Body=body})
    if res and (res.StatusCode==204 or res.StatusCode==200) then return true end
  end
  return false, res and res.StatusCode
end

local function b64(s)
  local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  return ((s:gsub('.', function(x)
    local r,bits='',x:byte()
    for i=8,1,-1 do r=r..(bits%2^i-bits%2^(i-1)>0 and '1' or '0') end
    return r
  end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
    if (#x<6) then return '' end
    local c=0; for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
    return b:sub(c+1,c+1)
  end)..({ '', '==', '=' })[#s%3+1])
end

local function fmt_money(n)
  n = tonumber(n) or 0
  local abs, unit, val = math.abs(n), "/s", n
  if abs >= 1e9 then val, unit = n/1e9, "B/s"
  elseif abs >= 1e6 then val, unit = n/1e6, "M/s"
  elseif abs >= 1e3 then val, unit = n/1e3, "K/s" end
  return ("$%s%s"):format(tostring(("%.2f"):format(val):gsub("%.?0+$","")), unit)
end

local function parse_mps(val)
  if typeof(val) == "number" then return val end
  if typeof(val) ~= "string" then return 0 end
  local s = val:lower()
  local num = tonumber((s:match("([%d%.]+)")) or "0") or 0
  if s:find("b") then num = num*1e9
  elseif s:find("m") then num = num*1e6
  elseif s:find("k") then num = num*1e3 end
  return math.floor(num + 0.5)
end

local ALLOW_NAME_TOKENS = {"mps","moneypersec","money_per_sec","moneypersecond","persec","per_second"}
local DENY_TOKENS       = {"offline","cash","total","bank","balance","wallet","coins","gems","price","cost","buy","sell","collect","collected"}

local function has_token(s, toks)
  s = tostring(s or ""):lower()
  for _,t in ipairs(toks) do if s:find(t, 1, true) then return true end end
  return false
end

local function text_is_per_sec(txt)
  local s = tostring(txt or ""):lower()
  return (s:find("/s", 1, true) ~= nil) or s:find("per%s*sec") or s:find("per%s*second")
end

local function collect_prices(container)
  local list = {}
  if not (container and container.GetDescendants) then return list end
  local ok, descs = pcall(container.GetDescendants, container)
  if not ok or type(descs) ~= "table" then return list end

  for i = 1, #descs do
    local d = descs[i]
    local nm_l = tostring(d.Name or ""):lower()
    if not has_token(nm_l, DENY_TOKENS) then
      if d:IsA("TextLabel") or d:IsA("TextButton") then
        local t = tostring(d.Text or "")
        if t ~= "" and text_is_per_sec(t) and not has_token(t, DENY_TOKENS) then
          local n = parse_mps(t); if n > 0 then list[#list+1] = n end
        end
      elseif d:IsA("StringValue") then
        local v = d.Value
        if type(v) == "string" and text_is_per_sec(v) and not has_token(v, DENY_TOKENS) then
          local n = parse_mps(v); if n > 0 then list[#list+1] = n end
        end
      elseif d:IsA("NumberValue") or d:IsA("IntValue") then
        if has_token(nm_l, ALLOW_NAME_TOKENS) then
          local n = tonumber(d.Value) or 0
          if n > 0 then list[#list+1] = n end
        end
      end
    end
  end

  for _,k in ipairs({"MoneyPerSec","MoneyPerSecond","MPS"}) do
    local a = container:GetAttribute(k)
    if a ~= nil then
      if typeof(a) == "number" and a > 0 then
        list[#list+1] = a
      elseif typeof(a) == "string" and text_is_per_sec(a) then
        local n = parse_mps(a); if n > 0 then list[#list+1] = n end
      end
    end
  end
  return list
end

local function gather_candidate_containers()
  local conts = {}
  local function add(x) if x then conts[#conts+1] = x end end

  for _, plr in ipairs(Players:GetPlayers()) do
    for _, nm in ipairs({"Pets","Inventory","PetInventory","Bag","Backpack"}) do
      add(plr:FindFirstChild(nm))
    end
    if plr == Players.LocalPlayer then add(plr:FindFirstChild("PlayerGui")) end
  end

  local RS = game:FindFirstChild("ReplicatedStorage"); add(RS)
  if RS then
    local ok, descs = pcall(RS.GetDescendants, RS)
    if ok and type(descs)=="table" then
      for i=1,#descs do
        local d = descs[i]
        if d:IsA("Folder") or d:IsA("ModuleScript") then
          local n = tostring(d.Name or ""):lower()
          if n:find("pet") or n:find("brainrot") then add(d) end
        end
      end
    end
  end

  add(game:GetService("Workspace"))
  return conts
end

local function find_rule_for_name(petName, RULES)
  local name = tostring(petName or ""):lower()
  for _, r in ipairs(RULES) do
    local key = tostring(r.k or ""):lower()
    if key ~= "" and name:find(key, 1, true) then return r end
  end
  return nil
end

local function prune_sort_prices(prices, rule, nameKey, sent_keys)
  local uniq, out = {}, {}
  for i=1,#prices do
    local p = prices[i]
    local okMin = (not rule.min) or (p >= rule.min)
    local okMax = (not rule.max) or (p <= rule.max)
    if okMin and okMax then
      local k = (nameKey or "") .. ":" .. tostring(p)
      if not uniq[p] and not (sent_keys and sent_keys[k]) then
        uniq[p] = true
        out[#out+1] = p
      end
    end
  end
  table.sort(out)
  return out
end

local function send_card(webhook_url, petName, prices_sorted, playersNow, playersMax, jobId)
  if not prices_sorted or #prices_sorted == 0 then return false end
  local jobB64 = b64(jobId)
  local lines = {}
  for i=1,#prices_sorted do lines[i] = fmt_money(prices_sorted[i]) end
  local listBlock = "```\n" .. table.concat(lines, "\n") .. "\n```"
  local payload = {
    username = "Brainrot Notify | TanPhu Hub",
    embeds = {{
      title = "Brainrot Notify | TanPhu Hub",
      color = 0x00AAFF,
      fields = {
        { name = "Name",              value = tostring(petName),                     inline = true },
        { name = "Money per sec",     value = fmt_money(prices_sorted[1]).." (min)", inline = true },
        { name = "Players",           value = tostring(playersNow).."/"..tostring(playersMax or 0), inline = true },
        { name = "Job ID (Mobile)",   value = "```"..jobB64.."```", inline = false },
        { name = "Job ID (iOS)",      value = "```"..jobB64.."```", inline = false },
        { name = "Job ID (PC)",       value = "```"..jobB64.."```", inline = false },
        { name = "Prices (low->high)",value = listBlock, inline = false },
      },
      footer = { text = "Made by TanPhu Hub" },
      timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
    }}
  }
  return _wh_post_json(webhook_url, payload)
end

-- -------------- per-notifier runner --------------
local function run_notifier(cfg)
  local ONE_SHOT      = cfg.ONE_SHOT or false
  local FIRST_DELAY   = cfg.FIRST_DELAY or 5
  local SCAN_INTERVAL = cfg.SCAN_INTERVAL or 60
  local WEBHOOK_URL   = cfg.WEBHOOK_URL
  local RULES         = cfg.RULES or {}
  local MAX_CARDS     = cfg.MAX_CARDS_PER_SERVER or 5

  local _reported_server_once = false
  local _sent_keys_global = {}

  local function scan_once()
    if ONE_SHOT and _reported_server_once then return end

    local sent = 0
    local playersNow = #Players:GetPlayers()
    local playersMax = (Players.MaxPlayers or 0)
    local jobId      = tostring(game.JobId)

    local containers = gather_candidate_containers()

    local nameKeys = {}
    for _,r in ipairs(RULES) do
      local k = tostring(r.k or ""):lower()
      if k ~= "" then nameKeys[k] = true end
    end

    local function try_send(name, prices_sorted)
      if sent >= MAX_CARDS then return end
      if send_card(WEBHOOK_URL, name, prices_sorted, playersNow, playersMax, jobId) then
        local base = tostring(name):lower()
        for i=1,#prices_sorted do
          _sent_keys_global[base..":"..tostring(prices_sorted[i])] = true
        end
        sent = sent + 1
      end
    end

    for i=1,#containers do
      local c = containers[i]
      local okDescs, descs = pcall(function()
        return (c and c.GetDescendants) and c:GetDescendants() or {}
      end)
      if okDescs and type(descs)=="table" then
        for j=1,#descs do
          local inst = descs[j]
          local nm = tostring(inst.Name or ""):lower()
          local matchedKey = nil
          for key,_ in pairs(nameKeys) do if nm:find(key, 1, true) then matchedKey = key break end end
          if matchedKey then
            local rule = find_rule_for_name(inst.Name, RULES)
            if rule then
              local prices = {}
              local function add_all(from)
                if not from then return end
                local ok, t = pcall(collect_prices, from)
                if ok and type(t)=="table" then
                  for k=1,#t do prices[#prices+1] = t[k] end
                end
              end
              add_all(inst)
              add_all(inst.Parent)
              add_all(inst.Parent and inst.Parent.Parent)

              local good = prune_sort_prices(prices, rule, nm, _sent_keys_global)
              if #good > 0 then
                try_send(inst.Name, good)
                if sent >= MAX_CARDS then break end
              end
            end
          end
        end
      end
      if sent >= MAX_CARDS then break end
    end

    if sent > 0 and ONE_SHOT then
      _reported_server_once = true
    end
  end

  task.spawn(function()
    task.wait(FIRST_DELAY)
    while true do
      pcall(scan_once)
      task.wait(SCAN_INTERVAL)
    end
  end)
end

-- ----------------- Notifier #1 (list + 4 items bạn thêm) -----------------
run_notifier({
  ONE_SHOT       = false,
  FIRST_DELAY    = 5,
  SCAN_INTERVAL  = 60,
  WEBHOOK_URL    = "https://discordapp.com/api/webhooks/1410314122670903491/KD8clDHrbOMKlArHAoEyMXTqQGD6AAN7ftlYvdkFEOj5a9_VEGA9yqAhoH2XPK77TITb",
  MAX_CARDS_PER_SERVER = 5,
  RULES = {
    { k = "graipuss medussi",       min = 10_000_000,   max = 20_000_000   },
    { k = "la grande combinasion",  min = 10_000_000,   max = 300_000_000  },
    { k = "los combinasionas",      min = 15_000_000,   max = 400_000_000  },
    { k = "nuclearo dinossauro",    min = 15_000_000,   max = 300_000_000  },
    { k = "los hotspotsitos",       min = 20_000_000,   max = 400_000_000  },
    { k = "garama and madundung",   min = 50_000_000,   max = 2_000_000_000},
    -- extra list you provided previously:
    { k = "esok sekolah",           min = 30_000_000,   max = 1_000_000_000 },
    { k = "dragon cannelloni",      min = 100_000_000,  max = 5_000_000_000 },
    { k = "la supreme combinasion", min = 40_000_000,   max = 4_000_000_000 },
    { k = "secret lucky block",     min = 30_000_000,   max = 700_000_000  },
  }
})

-- ----------------- Notifier #2 (bạn vừa gửi) -----------------
run_notifier({
  ONE_SHOT       = false,
  FIRST_DELAY    = 5,
  SCAN_INTERVAL  = 60,
  WEBHOOK_URL    = "https://discordapp.com/api/webhooks/1411329828904374293/elK3umTJvdL6h4ml-EHg9DbM1wCdQJFpOsNWEEB79T0P1hRstSgd_ep75KIp-aHdIdoK",
  MAX_CARDS_PER_SERVER = 5,
  RULES = {
    { k = "la vacca saturno saturnita",  min = 1_000_000,  max = 10_000_000 },
    { k = "torrtuginni dragonfrutini",   min = 1_000_000,  max = 10_000_000 },
    { k = "agarrini la palini",          min = 1_000_000,  max = 10_000_000 },
    { k = "los tralaleritos",            min = 1_000_000,  max = 10_000_000 },
    { k = "las tralaleritas",            min = 1_000_000,  max = 15_000_000 },
    { k = "job job job sahur",           min = 1_000_000,  max = 15_000_000 },
    { k = "las vaquitas saturnitas",     min = 1_000_000,  max = 10_000_000 },
    { k = "graipuss medussi",            min = 1_000_000,  max =  9_000_000 },
    { k = "pot hotspot",                 min = 1_000_000,  max = 30_000_000 },
    { k = "chicleteira bicicleteira",    min = 1_000_000,  max = 30_000_000 },
    { k = "los spyderinis",              min = 1_000_000,  max = 10_000_000 },
  }
})
-- =============================================================================
